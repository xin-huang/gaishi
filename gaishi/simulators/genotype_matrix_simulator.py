# Copyright 2025 Xin Huang
#
# GNU General Public License v3.0
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, please see
#
#    https://www.gnu.org/licenses/gpl-3.0.en.html


import h5py
import multiprocessing
import os
import shutil
import numpy as np
from gaishi.simulators import GenericSimulator
from gaishi.simulators import MsprimeSimulator
from gaishi.generators import PolymorphismDataGenerator
from gaishi.labelers import BinaryAlleleLabeler
from gaishi.preprocessors import GenotypeMatrixPreprocessor
from gaishi.utils import initialize_h5, write_h5, write_tsv


class GenotypeMatrixSimulator(GenericSimulator):
    """
    A simulator class that integrates simulation, labeling, and
    genotype-matrix construction to prepare training-ready inputs.

    This class automates the process of simulating genomic data,
    deriving per-site labels (e.g., introgressed vs non-introgressed),
    selecting and optionally upsampling polymorphic sites, and
    transforming the resulting genotypes into fixed-shape genotype
    matrices for reference and target samples. Optional preprocessing
    steps such as sorting or seriation can be applied to standardize
    matrix structure. The final matrices and labels can be exported in
    human-readable TSV format for inspection or in HDF5 format for
    efficient storage and high-throughput model training.
    """

    def __init__(
        self,
        demo_model_file: str,
        nref: int,
        ntgt: int,
        ref_id: str,
        tgt_id: str,
        src_id: str,
        ploidy: int,
        seq_len: int,
        mut_rate: float,
        rec_rate: float,
        output_prefix: str,
        output_dir: str,
        output_h5: bool,
        is_phased: bool,
        is_sorted: bool,
        keep_sim_data: bool,
        num_polymorphisms: int,
        num_upsamples: int,
        num_genotype_matrices: int,
    ):
        """
        Initialize a new instance of the GenotypeMatrixSimulator class.

        Parameters
        ----------
        demo_model_file : str
            Path to the demographic model file defining the simulation parameters.
        nref : int
            Number of samples in the reference population.
        ntgt : int
            Number of samples in the target population.
        ref_id : str
            Identifier for the reference population in the demographic model.
        tgt_id : str
            Identifier for the target population in the demographic model.
        src_id : str
            Identifier for the source population in the demographic model.
        ploidy : int
            Ploidy of the samples; typically 2 for diploid organisms.
        seq_len : int
            Length of the simulated sequence, in base pairs.
        mut_rate : float
            Mutation rate per base pair per generation.
        rec_rate : float
            Recombination rate per base pair per generation.
        output_prefix : str
            Prefix for the output files generated by the simulation.
        output_dir : str
            Directory where the output files will be stored.
        output_h5 : bool
            If True, output will be saved in HDF5 format. Otherwise, output will be saved in TSV format.
        is_phased : bool
            Indicates whether the simulated genomic data is phased.
        is_sorted : bool
            Indicates whether the simulated data should be sorted.
        keep_sim_data : bool
            If True, intermediate simulation data will be retained for further analysis.
        num_polymorphisms : int
            Number of polymorphic sites to simulate.
        num_upsamples : int
            Number of samples after upsampling to generate.
        num_genotype_matrices: int
            Number of genotype matrices for training.
        """

        self.simulator = MsprimeSimulator(
            demo_model_file=demo_model_file,
            nref=nref,
            ntgt=ntgt,
            ref_id=ref_id,
            tgt_id=tgt_id,
            src_id=src_id,
            ploidy=ploidy,
            seq_len=seq_len,
            mut_rate=mut_rate,
            rec_rate=rec_rate,
            output_prefix=output_prefix,
            output_dir=output_dir,
            is_phased=is_phased,
        )

        self.labeler = BinaryAlleleLabeler(
            ploidy=ploidy,
            is_phased=is_phased,
            num_polymorphisms=num_polymorphisms,
        )

        self.ploidy = ploidy
        self.is_phased = is_phased
        self.is_sorted = is_sorted
        self.keep_sim_data = keep_sim_data
        self.num_polymorphisms = num_polymorphisms
        self.num_upsamples = num_upsamples
        self.num_genotype_matrices = num_genotype_matrices
        self.output_h5 = output_h5

        os.makedirs(output_dir, exist_ok=True)
        if self.output_h5:
            self.output = os.path.join(output_dir, f"{output_prefix}.h5")
            initialize_h5(
                file_name=self.output,
                ds_type="train",
                num_genotype_matrices=self.num_genotype_matrices,
                N=nref * self.ploidy,
                L=self.num_polymorphisms,
                chromosome="1",
                ref_table=[f"tsk_{i}" for i in range(nref)],
                tgt_table=[f"tsk_{i}" for i in range(nref, nref + ntgt)],
            )
        else:
            self.output = os.path.join(output_dir, f"{output_prefix}.tsv")
            with open(self.output, "w") as f:
                f.write(
                    "Chromosome\t"
                    + "Start\t"
                    + "End\t"
                    + "Position\t"
                    + "Position_index\t"
                    + "Gap_to_prev\t"
                    + "Gap_to_next\t"
                    + "Ref_sample\t"
                    + "Ref_genotype\t"
                    + "Tgt_sample\t"
                    + "Tgt_genotype\t"
                    + "Replicate\t"
                    + "Seed\t"
                    + "Label\n"
                )

    def run(self, rep: int = None, seed: int = None, **kwargs) -> None:
        """
        Execute the simulation and preprocessing pipeline.

        Parameters
        ----------
        rep : int, optional
            The replicate number for the simulation run. If not provided, a default value is used.
        seed : int, optional
            The random seed for reproducibility. If not provided, a default value is used.
        """

        file_paths = self.simulator.run(rep=rep, seed=seed)[0]

        labels = self.labeler.run(
            vcf_file=file_paths["vcf_file"],
            tgt_ind_file=file_paths["tgt_ind_file"],
            true_tract_file=file_paths["bed_file"],
            rep=rep,
        )

        polymorphism_data_generator = PolymorphismDataGenerator(
            vcf_file=file_paths["vcf_file"],
            ref_ind_file=file_paths["ref_ind_file"],
            tgt_ind_file=file_paths["tgt_ind_file"],
            chr_name="1",
            random_polymorphisms=True,
            num_polymorphisms=self.num_polymorphisms,
            num_upsamples=self.num_upsamples,
            ploidy=self.ploidy,
            is_phased=self.is_phased,
            seed=seed,
        )

        preprocessor = GenotypeMatrixPreprocessor(
            ref_ind_file=file_paths["ref_ind_file"],
            tgt_ind_file=file_paths["tgt_ind_file"],
            ref_rdm_spl_idx=polymorphism_data_generator.ref_rdm_spl_idx,
            tgt_rdm_spl_idx=polymorphism_data_generator.tgt_rdm_spl_idx,
            is_sorted=self.is_sorted,
        )

        data_dict = preprocessor.run(
            **list(polymorphism_data_generator.get())[0],
        )[0]

        if rep is not None:
            data_dict["Replicate"] = rep
        if seed is not None:
            data_dict["Seed"] = seed

        tgt_labels = []
        for sample in data_dict["Tgt_sample"]:
            tgt_labels.append(labels[sample]["Label"][data_dict["Position_index"]])

        data_dict["Label"] = np.array(tgt_labels)

        self._output_res(
            file_name=self.output,
            output_h5=self.output_h5,
            group_name_prefix="unet.training",
            data_dict=data_dict,
            rep=rep,
            num_genotype_matrices=self.num_genotype_matrices,
            force_balanced=kwargs["force_balanced"],
            nintro=kwargs["nintro"],
            nnonintro=kwargs["nnonintro"],
            only_intro=kwargs["only_intro"],
            only_non_intro=kwargs["only_non_intro"],
            lock=kwargs["lock"],
        )

        if not self.keep_sim_data:
            shutil.rmtree(os.path.dirname(file_paths["vcf_file"]), ignore_errors=True)

    def _output_res(
        self,
        file_name: str,
        output_h5: bool,
        group_name_prefix: str,
        data_dict: dict,
        rep: int,
        num_genotype_matrices: int,
        force_balanced: bool,
        nintro: multiprocessing.Value,
        nnonintro: multiprocessing.Value,
        only_intro: bool,
        only_non_intro: bool,
        lock: multiprocessing.Lock,
    ) -> None:
        """
        Output the data dictionary to a file in either HDF5 or TSV format.

        Parameters
        ----------
        file_name : str
            Path to the output file.
        output_h5 : bool
            Flag to determine if the output should be in HDF5 format.
        group_name_prefix : str
            Prefix for the group name in the HDF5 file.
        data_dict : dict
            Dictionary containing the data to be written to the file.
        rep : int
            Replicate number.
        number_genotype_matrices : int
            Maximum number of genotype matrices to write.
        force_balanced : bool
            Flag to enable balancing of introgressed and non-introgressed regions.
        nintro : multiprocessing.Value
            Shared counter for the number of introgressed regions.
        nnonintro : multiprocessing.Value
            Shared counter for the number of non-introgressed regions.
        only_intro : bool
            Flag to include only introgressed regions.
        only_non_intro : bool
            Flag to include only non-introgressed regions.
        lock : multiprocessing.Lock
            Lock for synchronizing multiprocessing operations.
        """
        label_sum = np.sum(data_dict["Label"])
        if only_intro and (label_sum == 0):
            return
        if only_non_intro and (label_sum != 0):
            return

        write_data = False
        with lock:
            if nintro.value + nnonintro.value < num_genotype_matrices:
                if force_balanced:
                    if label_sum == 0 and nnonintro.value < int(
                        num_genotype_matrices / 2
                    ):
                        write_data = True
                        nnonintro.value += 1
                    elif (
                        label_sum != 0
                        and nintro.value < int(num_genotype_matrices / 2) + 1
                    ):
                        write_data = True
                        nintro.value += 1
                else:
                    write_data = True
                    if label_sum == 0:
                        nnonintro.value += 1
                    if label_sum != 0:
                        nintro.value += 1

        if write_data:
            if output_h5:
                write_h5(
                    file_name=file_name,
                    entries=data_dict,
                    ds_type="train",
                    lock=lock,
                )
            else:
                write_tsv(
                    file_name=file_name,
                    data_dict=data_dict,
                    lock=lock,
                )
